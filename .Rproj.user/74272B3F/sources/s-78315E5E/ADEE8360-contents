# Profit Maximizing Marketing Experiments

# Code to test functions for computing expected profits and optimal sample size
# for the normal normal model

# Elea McDonnell Feit, eleafeit@gmail.com
# 6 May 2018
# Updated 6 July 2018

setwd("~/repos/profit_max_experiments")

# ----- Normal-Normal model example usage
rm(list=ls())
source("nn_functions.R")
#library(ggmosaic)
library(ggplot2)
library(tidyr)

# symmetric example
s <- 1; mu <- 1; sigma <- 0.2
plot_prior_mean_resp_nn(mu1=mu, sigma1=sigma)
plot_prior_resp_nn(s1=s, mu1=mu, sigma1=sigma)
plot_prior_effect_nn(mu1=mu, sigma1=sigma)
plot_prior_effect_nn(mu1=mu, sigma1=sigma, abs=TRUE)
(n <- test_size_nn(N=10000, s1=s, sigma1=sigma))
profit_nn(n=n, N=10000, s1=s, mu1=mu, sigma1=sigma)
test_eval_nn(n=n, N=10000, s1=sigma, mu1=mu, sigma1=sigma) # optimal test peformance
# stacked area plot of test size versus expected profit
evals <- NULL
for (i in 1:1000) evals <- rbind(evals, test_eval_nn(n=c(i, i),  N=10000, s1=s, mu1=mu, sigma1=sigma))
evals %>% 
  gather(Source, profit_plot, profit_test:profit_deploy) %>% 
  ggplot(aes(x=n1, y=profit_plot, fill=Source)) + 
  geom_area() + scale_fill_grey() +  theme_bw() +
  xlab("Test Size (n1 = n2)") + ylab("Expected Profit") + 
  ggtitle("Expected Profit", subtitle="Normal-Normal Model: s1=s2=1, mu1=mu2=1, sigma1=sigma2=0.2")
# expected "confusion matrix"
sim <- profit_nn_sim(n=c(232, 232), N=10000, s1=1, mu1=1, sigma1=0.2, R=5000, draws=TRUE)
plot(xtabs(~ deploy + best, data=sim$draws), main="Deployment and Error Rates", 
     xlab="Deployed Treatment", ylab="Better Treatment")
#ggplot(data = sim$draws) + geom_mosaic(aes(x = product(deploy, best), fill=factor(best)), na.rm=TRUE) +    
#  theme_bw() + xlab("Probability of Deploying Treatment") + ylab("Better Treatment") +
#  ggtitle('Error Rates for Normal-Normal Model', subtitle="Normal-Normal Model: s1=s2=1, mu1=mu2=1, sigma1=sigma2=0.2") 

# asymmetric example
s1 <- 1; mu1 <- 1; sigma1 <- 0.2; s2 <- 1; mu2 <- 1.1; sigma2 <- 0.2
plot_prior_mean_resp_nn(mu1=mu, sigma1=sigma, mu2=mu2, sigma2=sigma2)
plot_prior_resp_nn(s1=s, mu1=mu, sigma1=sigma, s2=s2, mu2=mu2, sigma2=sigma2)
plot_prior_effect_nn(mu1=mu, sigma1=sigma, mu2=mu2, sigma2=sigma2)
plot_prior_effect_nn(mu1=mu, sigma1=sigma, mu2=mu2, sigma2=sigma2, abs=TRUE)
(n <- test_size_nn(N=10000, s1=s1, mu1=mu1, sigma1=sigma1, s2=s2, mu2=mu2, sigma2=sigma2))
profit_nn(n=n, N=10000, s1=s1, mu1=mu1, sigma1=sigma1, s2=s2, mu2=mu2, sigma2=sigma2)
test_eval_nn(n=n, N=10000, s1=s1, mu1=mu1, sigma1=sigma1, s2=s2, mu2=mu2, sigma2=sigma2)
# expected profit as a function of test size
evals <- NULL
for (n1 in seq(10,500,5)) {
  for (n2 in seq(10,500,5)) {
    evals <- rbind(evals, test_eval_nn(n=c(n1, n2), N=10000, s1=s1, mu1=mu1, sigma1=sigma1, s2=s2, mu2=mu2, sigma2=sigma2))
  }
} 
ggplot(evals, aes(n1, n2, z=profit)) + geom_raster(aes(fill=profit)) + 
  scale_fill_gradientn(colours=c("black", "black", "white")) + 
  geom_contour(colour="black", binwidth=0.001) + geom_point(aes(x=n[1], y=n[2]), colour="black") +
  xlab("Test Size Treatment 1 (n1)") + ylab("Test Size Treatment 2 (n2)") + 
  ggtitle("Expected Profit per Customer", subtitle="Normal-Normal Model: s1=s2=1, mu1=mu2=1, sigma1=sigma2=0.2")
# expected "confusion matrix"
sim <- profit_nn_sim(n=n, N=10000, s1=s1, mu1=mu1, sigma1=sigma1, s2=s2, mu2=mu2, sigma2=sigma2, 
                     R=5000, draws=TRUE) # treatment 2 deployed more often
plot(xtabs(~ deploy + best, data=sim$draws), main="Deployment and Error Rates", 
     xlab="Deployed Treatment", ylab="Better Treatment")

# ----- Normal-Normal model checks
# symmetric, asymmetric and simulated expected profits all match
rm(list=ls())
source("nn_functions.R")
s <- 1; mu <- 1; sigma <- 0.2; N <- 100; n=c(25,25)
sym <- test_eval_nn(n=n, N=N, s1=s, mu1=mu, sigma1=sigma)
asym <- test_eval_nn(n=n, N=N, s1=s, mu1=mu, sigma1=sigma, s2=s, mu2=mu, sigma2=sigma)
sim <- profit_nn_sim(n=n, N=N, s1=s, mu1=mu, sigma1=sigma, R=200000, draws=TRUE)
rbind(sym, asym, sim$summary)
hist(sim$draws$profit, main="Distribution of Profit", xlab="Profit", freq=FALSE)
abline(v=sim$summary$profit, col="blue")
abline(v=sym$profit, lty=3, col="red")
abline(v=asym$profit, lty=3, col="red")

# increasing n1 an n2 lowers error rate
rm(list=ls())
source("nn_functions.R")
s <- 1; mu <- 1; sigma <- 0.2; N <- 100; n=c(25,25)
test_eval_nn(n=c(10,10), N=10000, s1=s, mu1=mu, sigma1=sigma)
test_eval_nn(n=n, N=10000, s1=s, mu1=mu, sigma1=sigma)
test_eval_nn(n=c(500,500), N=10000, s1=s, mu1=mu, sigma1=sigma)
test_eval_nn(n=c(1000,1000), N=10000, s1=s, mu1=mu, sigma1=sigma)

# optimal test sizes match complete enumeration
rm(list=ls())
source("nn_functions.R")
s1 <- 1; mu1 <- 1; sigma1 <- 0.2; s2 <- 1; mu2 <- 1.05; sigma2 <- 0.2; N <- 10000
# symmetric
profits <- rep(NA, 1000)
for (i in 1:1000) profits[i] <- profit_nn(n=c(i,i), N=10000, s1=s1, mu1=mu1, sigma1=sigma1)
which.max(profits)
round(test_size_nn(N=10000, s1=s1, sigma1=sigma1))
# asymmetric
profits <- matrix(nrow=1000, ncol=1000)
for (i in 1:1000) {
  for (j in 1:1000) {
    profits[i,j] <- profit_nn(n=c(i,j), N=10000, s1=s1, mu1=mu1, sigma1=sigma1, s2=s2, mu2=mu2, sigma2=sigma2)
  }
}
which(profits == max(profits), arr.ind=TRUE)
round(test_size_nn(N=10000, s1=1, mu1=1, sigma1=0.2, s2=1, mu2=1.05, sigma2=0.2))  # calls optim L-BFGS-S

# increasing s increases optimal test size and decreases profits
rm(list=ls())
source("nn_functions.R")
s <- c(0.5, 1, 2); mu <- 1; sigma <- 0.2; N <- 10000
(n1 <- test_size_nn(N=N, s1=s[1], sigma1=sigma))
(n2 <- test_size_nn(N=N, s1=s[2], sigma1=sigma))
(n3 <- test_size_nn(N=N, s1=s[3], sigma1=sigma))
profit_nn(n=n1, N=N, s1=s[1], mu1=mu, sigma1=sigma)
profit_nn(n=n2, N=N, s1=s[2], mu1=mu, sigma1=sigma)
profit_nn(n=n3, N=N, s1=s[3], mu1=mu, sigma1=sigma)

# increasing sigma increases profits and decreases optimal test size
rm(list=ls())
source("nn_functions.R")
s <- 1; mu <- 1; sigma <- c(0.1, 0.2, 1); N <- 10000
(n1 <- test_size_nn(N=N, s1=s, sigma1=sigma[1]))
(n2 <- test_size_nn(N=N, s1=s, sigma1=sigma[2]))
(n3 <- test_size_nn(N=N, s1=s, sigma1=sigma[3]))
profit_nn(n=n1, N=N, s1=s, mu1=mu, sigma1=sigma[1])
profit_nn(n=n2, N=N, s1=s, mu1=mu, sigma1=sigma[2])
profit_nn(n=n3, N=N, s1=s, mu1=mu, sigma1=sigma[3])

# increasing mu increases profits (but not incremental profit) and leaves optimal test size unchanged
rm(list=ls())
source("nn_functions.R")
s <- 1; mu <- c(1, 2, 3); sigma <- 0.2; N <- 10000
(n1 <- test_size_nn(N=N, s1=s, mu1=mu[1], sigma1=sigma))
(n2 <- test_size_nn(N=N, s1=s, mu1=mu[2], sigma1=sigma))
(n3 <- test_size_nn(N=N, s1=s, mu1=mu[3], sigma1=sigma))
(n1 <- test_size_nn(N=N, s1=s, mu1=mu[1], sigma1=sigma, s2=s, mu2=mu[1], sigma2=sigma))
(n1 <- test_size_nn(N=N, s1=s, mu1=mu[2], sigma1=sigma, s2=s, mu2=mu[2], sigma2=sigma))
(n1 <- test_size_nn(N=N, s1=s, mu1=mu[2], sigma1=sigma, s2=s, mu2=mu[2], sigma2=sigma))
profit_nn(n=n1, N=N, s1=s, mu1=mu[1], sigma1=sigma)
profit_nn(n=n2, N=N, s1=s, mu1=mu[2], sigma1=sigma)
profit_nn(n=n3, N=N, s1=s, mu1=mu[3], sigma1=sigma)

# swapping inputs in assymetric tests yields same answers
rm(list=ls())
source("nn_functions.R")
n <- c(100, 100); s1 <- 1; mu1 <- 1; sigma1 <- 0.2; s2 <- 5; mu2 <- 1.05; sigma2 <- 0.5; N <- 10000
out1 <- test_eval_nn(n=c(100, 200), N=N, s1=s1, mu1=mu1, sigma1=sigma1, s2=s1, mu2=mu1, sigma2=sigma1)
out2 <- test_eval_nn(n=c(200, 100), N=N, s1=s1, mu1=mu1, sigma1=sigma1, s2=s1, mu2=mu1, sigma2=sigma1)
rbind(out1, out2)
out1 <- test_eval_nn(n=n, N=N, s1=s1, mu1=mu1, sigma1=sigma1, s2=s2, mu2=mu1, sigma2=sigma1)
out2 <- test_eval_nn(n=n, N=N, s1=s2, mu1=mu1, sigma1=sigma1, s2=s1, mu2=mu1, sigma2=sigma1)
rbind(out1, out2)
out1 <- test_eval_nn(n=n, N=N, s1=s1, mu1=mu2, sigma1=sigma1, s2=s1, mu2=mu1, sigma2=sigma1)
out2 <- test_eval_nn(n=n, N=N, s1=s1, mu1=mu1, sigma1=sigma1, s2=s1, mu2=mu2, sigma2=sigma1)
rbind(out1, out2)
out1 <- test_eval_nn(n=n, N=N, s1=s1, mu1=mu1, sigma1=sigma1, s2=s1, mu2=mu1, sigma2=sigma2)
out2 <- test_eval_nn(n=n, N=N, s1=s1, mu1=mu1, sigma1=sigma2, s2=s1, mu2=mu1, sigma2=sigma1)
rbind(out1, out2)

# null hypothesis testing sample size checks
test_size_nht(s=1, delta=0.1)
power.t.test(delta=0.1, sd=1, power=0.8)
test_size_nht(s1=1, s2=2, delta=0.1, conf=0.95, power=0.8)
library("samplesize")
n.ttest(sd1=1, sd2=2, mean.diff=0.1, alpha=0.05, power=0.8, 
        fraction="unbalanced", variance="unequal")

# Null Hypothesis Sample Size (test_size_nht) -----
# asymetric and symetric formulae are consistent without FPC
test_size_nht(s=1, d=0.1) == test_size_nht(s=c(1,1), d=0.1)[1]
# asymetric produces different sample sizes for each arm
n <- test_size_nht(s=c(1,2), d=0.1)
n[1] != n[2]
# aymetric and symetric formulae are consistet with FPC
test_size_nht(s=1, d=0.1, N=100000) == test_size_nht(s=c(1,1), d=0.1, N=100000)[1]
# FPC makes the sample size smaller
test_size_nht(s=1, d=0.1) > test_size_nht(s=1, d=0.1, N=100000)
test_size_nht(s=1, d=0.1, N=100000) > test_size_nht(s=1, d=0.1, N=1000)

# Profit for two arms (profit_nn) -----
# Symmetric and assymetric profits match
profit_nn(c(100,100), N=1000, s=0.5, mu=1, sigma=0.1)
profit_nn(c(100,100), N=1000, s=c(0.5, 0.5), mu=c(1, 1), sigma=c(0.1, 0.1))

# Profit for K arms (profit_nn_sim) -----
# Simulated profit roughly matches closed-form for symmetric case
profit_nn(n=100, N=1000, s=0.5, mu=1, sigma=0.1)
print(system.time(out <- profit_nn_sim(n=100, N=1000, s=0.5, mu=1, sigma=0.1, R=10000)))
out$profit
out$regret
error_rate_nn(n=100, s=0.5, sigma=0.1)
out$error

# Runs with Thompson sampling
print(system.time(out <- profit_nn_sim(n=100, N=1000, s=0.01, mu=1, sigma=0.1, TS=TRUE)))
out$profit
out$regret
# Simulated profit roughtly matches closed form for asymmetric case
profit_nn(n=100, N=1000, s=c(0.5, 0.5), mu=c(1,1.1), sigma=c(0.1, 0.1))
print(system.time(out <- profit_nn_sim(n=100, N=1000, s=c(0.5, 0.5), mu=c(1, 1.1), 
                                       sigma=c(0.1, 0.1), R=10000) ))
out$profit
out$regret
# More arms produces higher profit overall and greater regret 
out <- profit_nn_sim(n=100, N=1000, s=0.5, mu=1, sigma=0.1, K=2, TS=TRUE) # two-arm symmetric
out$profit
out$regret
out <- profit_nn_sim(n=100, N=1000, s=0.5, mu=1, sigma=0.1, K=3, TS=TRUE) # three-arm symmetric
out$profit
out$regret
out <- profit_nn_sim(n=100, N=1000, s=0.5, mu=1, sigma=0.1, K=4, TS=TRUE) # three-arm symmetric
out$profit
out$regret

# Test size two arms (test_size_nn) -----
# Closed form symmetrics and assymetric optimization match
test_size_nn(N=1000, s=0.5, mu=1, sigma=0.1)
test_size_nn(N=1000, s=rep(0.5,2), mu=rep(1,2), sigma=rep(0.1,2))
# Asymmetric form produced unequal sample sizes
test_size_nn(N=1000, s=rep(0.5,2), mu=c(1,1.1), sigma=rep(0.1,2))

# Test size K arms (test_size_nn_sim) -----
# simulated test size approximates close form
(n <- test_size_nn(N=1000, s=0.5, mu=1, sigma=0.1))
profit_nn(n=n, N=1000, s=0.5, mu=1, sigma=0.1)
test_size_nn_sim(N=1000, s=0.5, mu=1, sigma=0.1, R=10000)
# sample sizes get smaller for more arms (but profit goes up)
test_size_nn_sim(N=1000, s=0.5, mu=1, sigma=0.1, K=3)
test_size_nn_sim(N=1000, s=0.5, mu=1, sigma=0.1, K=8)

